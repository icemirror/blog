# 垃圾收集（GC）机制

Javascript具有自动垃圾收集（garbage collection）机制， 执行环境会负责管理代码执行过程中使用的内存。而C或C++这类的语言，则需要手工跟踪内存的使用情况。

**垃圾收集的实现原理**： 标记那些不再继续使用的变量，然后释放其占有的内存。通常用于标记无用变量的策略有2种。

### 标记清除

**标记清除**（mark-and-sweep）是最常见的垃圾收集方式。它的原理是：当变量进入环境（eg: 在函数中声明一个变量）时，就将这个变量标记为"进入环境"，当变量离开环境时，就将其标记为"离开环境"。

标记清除策略是在程序运行时**将存储到内存中的所有变量都添加上标记，然后它会去掉环境中的变量和被环境中的变量引用的变量的标记**。此后，仍有标记的变量就被视为等待被清除的变量。垃圾收集器完成内存清除工作：摧毁那些标记的值，并回收它们占用的内存空间。

> 到2008年为止,IE、Firefox、Opera、Chrome和Safari的Javascript实现使用的都是标记清除式垃圾收集策略(或者类似的策略).只不过垃圾收集的时间间隔互不相同.

### 引用计数

**引用计数**(reference counting)是另一种不太常见的垃圾收集机制。它的工作原理是：跟踪记录每个值被引用的次数。当声明了一个变量并被赋值一个引用类型的值时，这个值的引用次数就是1。如果同一个值赋给另一个变量，那么引用次数加1。如果引用这个值的变量被赋值为另一个值时，这个值的引用次数减1。当这个值的引用次数变为0时，就意味着这个值无任何引用关系，无法再放问这个值了，当垃圾收集器在运行的时候，就会将这些引用次数为0的值所占有的内存释放掉。

但是引用计数遇到了一个很严重的问题，无法解决**循环引用**的问题。循环引用指的是：对象A包含了一个指向对象B的指针，而对象B也包含了一个指向对象A的指针。那么A和B的引用计数就永远也不会为0。

```js
function problem() {
  var objectA = new Object()
  var objectB = new Object()
  objectA.someProp = objectB
  objectB.anotherProp = objectA
}
```
在这个情况下，objectA和objectB有循环引用的关系。如果problem函数被重复调用多次，那么会造成大量的内存无法被回收。因此，netscape在navigator4.0就放弃了引用计数方式，而采用了标记清除来实现垃圾收集。

### 管理内存

出于安全方面的考虑，默认情况下，分配给web浏览器的可用内存通常要比分配给桌面端应用的内存要少。这样会防止在浏览一些JavaScript页面时，由于占用内存过大而导致整个操作系统的崩溃。

为了确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式就是：为执行中的代码只保留必要的数据。一旦数据不会再用的时候，手动将其置为```null```，从而释放掉值的内存空间——这种做法叫做解除引用（deferencing）。解除引用的操作有助于消除循环引用现象。

```js
function createPerson(name) {
  var localPerson = new Object()
  localPerson.name = name
  return localPerson
}
var globalPerson = createPerson('mark')

// 手动解除globalPerson的引用
globalPerson = null
```

对于局部变量，在代码被执行后会被自动清除，而**对于全局对象、全局对象属性及循环引用变量的引用**而言，则需要手动解除引用，以便下一次垃圾收集器运行时将其回收。


### 参考资料

- 变量、作用域和内存问题 - 垃圾收集(高级程序设计第3版)
